// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

/**
 * This code includes portions of REV Robotics' MaxSwerve-Java-Template which is available at https://github.com/REVrobotics/MAXSwerve-Java-Template
 */

package frc.robot.subsystems;

import java.util.function.Consumer;
import java.util.Map;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.DriverStation.Alliance;
import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Pose3d;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.geometry.Rotation3d;
import edu.wpi.first.math.kinematics.ChassisSpeeds;
import edu.wpi.first.math.kinematics.SwerveDriveKinematics;
import edu.wpi.first.math.kinematics.SwerveModulePosition;
import edu.wpi.first.math.kinematics.SwerveModuleState;
import edu.wpi.first.networktables.NetworkTable;
import edu.wpi.first.networktables.NetworkTableInstance;
import edu.wpi.first.math.filter.SlewRateLimiter;
import edu.wpi.first.util.WPIUtilJNI;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import edu.wpi.first.wpilibj.smartdashboard.Field2d;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.InstantCommand;
import edu.wpi.first.wpilibj2.command.SequentialCommandGroup;
import edu.wpi.first.math.MathUtil;
import edu.wpi.first.math.controller.PIDController;
import edu.wpi.first.math.estimator.SwerveDrivePoseEstimator;
import edu.wpi.first.networktables.GenericEntry;
import edu.wpi.first.wpilibj.shuffleboard.BuiltInWidgets;
import edu.wpi.first.wpilibj.shuffleboard.Shuffleboard;
import edu.wpi.first.wpilibj.shuffleboard.ShuffleboardTab;
import edu.wpi.first.wpilibj.shuffleboard.WidgetType;
import com.pathplanner.lib.commands.PPSwerveControllerCommand;
import com.pathplanner.lib.PathPlannerTrajectory;
import frc.robot.NavX;
import frc.robot.Robot;
import frc.robot.Constants.DriveConstants;
import frc.robot.Constants.LimeLightConstants;
import frc.robot.Constants.AutoConstants;
import frc.utils.SwerveUtils;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class DriveTrain extends SubsystemBase {
  private boolean m_fieldOriented = true;
  private boolean m_slew = true;
  private double m_driveLockLR = 1;
  private double m_driveLockFR = 1;
  private int m_targetNode = 7;
  private double m_rotationLock = 1;
  private double fieldOffsetAngle = 0; // Default orientation of robot on field
  private double rotAmount = 0;
  private double m_currentXSpeed = 0;
  private double m_currentYSpeed = 0;

  // Vars added for driver training, aka veriable "turtle" mode
  private double maxSpeedDrive = 1.0;
  private double maxSpeedRotation = 1.0;

  private Alliance alliance;

  // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

  // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

  // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

  // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

  private final MaxSwerveModule m_frontLeft = new MaxSwerveModule(
      DriveConstants.kFrontLeftDrivingCanId,
      DriveConstants.kFrontLeftTurningCanId,
      DriveConstants.kFrontLeftChassisAngularOffset);

  private final MaxSwerveModule m_frontRight = new MaxSwerveModule(
      DriveConstants.kFrontRightDrivingCanId,
      DriveConstants.kFrontRightTurningCanId,
      DriveConstants.kFrontRightChassisAngularOffset);

  private final MaxSwerveModule m_backLeft = new MaxSwerveModule(
      DriveConstants.kBackLeftDrivingCanId,
      DriveConstants.kBackLeftTurningCanId,
      DriveConstants.kBackLeftChassisAngularOffset);

  private final MaxSwerveModule m_backRight = new MaxSwerveModule(
      DriveConstants.kBackRightDrivingCanId,
      DriveConstants.kBackRightTurningCanId,
      DriveConstants.kBackRightChassisAngularOffset);

  private final NavX m_gyro = new NavX();

  // Slew rate filter variables for controlling lateral acceleration
  private double m_currentRotation = 0.0;
  private double m_currentTranslationDir = 0.0;
  private double m_currentTranslationMag = 0.0;
  private double m_TagID = 0.0;

  private SlewRateLimiter m_magLimiter = new SlewRateLimiter(DriveConstants.kMagnitudeSlewRate);
  private SlewRateLimiter m_rotLimiter = new SlewRateLimiter(DriveConstants.kRotationalSlewRate);
  private double m_prevTime = WPIUtilJNI.now() * 1e-6;

  SwerveDrivePoseEstimator m_odometry = new SwerveDrivePoseEstimator(DriveConstants.kDriveKinematics,
      Rotation2d.fromDegrees(m_gyro.getYaw() + getFieldOffsetAngle()),
      new SwerveModulePosition[] {
          m_frontLeft.getPosition(),
          m_frontRight.getPosition(),
          m_backLeft.getPosition(),
          m_backRight.getPosition() },
      new Pose2d());
  public Consumer<SwerveModuleState[]> setModuleStates;

  /*
   * Drive Train Code
   */
  public DriveTrain() {
    alliance = DriverStation.getAlliance();
    visionData = NetworkTableInstance.getDefault().getTable("limelight");
    m_odometry = new SwerveDrivePoseEstimator(DriveConstants.kDriveKinematics,
        Rotation2d.fromDegrees(m_gyro.getYaw() + getFieldOffsetAngle()), new SwerveModulePosition[] {
            m_frontLeft.getPosition(),
            m_frontRight.getPosition(),
            m_backLeft.getPosition(),
            m_backRight.getPosition(),
        }, new Pose2d());
  }

  // Init veriable turtle mode
  private ShuffleboardTab tab = Shuffleboard.getTab("Automated");
  private GenericEntry maxDriveSpeed = tab.add("Max Drive Speed", 1).withWidget(BuiltInWidgets.kNumberSlider)
      .withProperties(Map.of("Min", 0, "Max", 1)).getEntry();
  private GenericEntry maxRotateSpeed = tab.add("Max Rotational Speed", 1).withWidget(BuiltInWidgets.kNumberSlider)
      .withProperties(Map.of("Min", 0, "Max", 1)).getEntry();

  @Override
  public void periodic() {
    updateFieldOffset();
    m_odometry.update(Rotation2d.fromDegrees(m_gyro.getYaw() + getFieldOffsetAngle()),
        new SwerveModulePosition[] {
            m_frontLeft.getPosition(),
            m_frontRight.getPosition(),
            m_backLeft.getPosition(),
            m_backRight.getPosition()
        });
    this.setMaxDriveSpeed(maxDriveSpeed.getDouble(1.0));
    this.setMaxRotationalSpeed(maxRotateSpeed.getDouble(1.0));
  }

  @Override
  public void simulationPeriodic() {
    // This method will be called once per scheduler run when in simulation

  }

  public SwerveDrivePoseEstimator getOdometry() {
    return m_odometry;
  }

  public MaxSwerveModule getFrontLeft() {
    return m_frontLeft;
  }

  public MaxSwerveModule getFrontRight() {
    return m_frontRight;
  }

  public MaxSwerveModule getBackLeft() {
    return m_backLeft;
  }

  public MaxSwerveModule getBackRight() {
    return m_backRight;
  }

  public double boundInput(double value, double bound) {
    if (Math.abs(value) <= Math.abs(bound)) {
      return value;
    } else {
      if (value > 0) {
        return Math.abs(bound);
      } else {
        return -Math.abs(bound);
      }
    }
  }

  public double getMaxDriveSpeed() {
    // Always return 1 (full speed) during auton
    return (edu.wpi.first.wpilibj.DriverStation.isAutonomous()) ? 1 : maxSpeedDrive;
  }

  public double getMaxRotationalSpeed() {
    // Always return 1 (full speed) during auton
    return (edu.wpi.first.wpilibj.DriverStation.isAutonomous()) ? 1 : maxSpeedRotation;
  }

  public void setMaxDriveSpeed(double speed) {
    if (speed >= 0 && speed <= 1) {
      maxSpeedDrive = speed;
    } else {
      // Speed out of bounds, ignore update
    }
  }

  public void setMaxRotationalSpeed(double speed) {
    if (speed >= 0 && speed <= 1) {
      maxSpeedRotation = speed;
    } else {
      // Speed out of bounds, ignore update
    }
  }

  public String getTargetNode() {
    return LimeLightConstants.nodeLocationString[m_targetNode];
  }

  public void addTargetNode() {
    if (m_targetNode < 8) {
      m_targetNode = m_targetNode + 1;
    }
  }

  public void subTargetNode() {
    if (m_targetNode > 0) {
      m_targetNode = m_targetNode - 1;
    }
  }

  /**
   * Returns the currently-estimated pose of the robot.
   *
   * @return The pose.
   */
  public Pose2d getPose() {
    return m_odometry.getEstimatedPosition();
  }

  /**
   * Resets the odometry to the specified pose.
   *
   * @param pose The pose to which to set the odometry.
   */
  public void resetOdometry(Pose2d pose) {
    m_odometry.resetPosition(
        Rotation2d.fromDegrees(m_gyro.getYaw() + getFieldOffsetAngle()),
        new SwerveModulePosition[] {
            m_frontLeft.getPosition(),
            m_frontRight.getPosition(),
            m_backLeft.getPosition(),
            m_backRight.getPosition()
        },
        pose);
  }

  public Pose3d getVisionPose(NetworkTable visionData) {
    if (visionData.getEntry("tv").getDouble(0) == 0) {
      return null;
    }
    Pose3d robotPose;
    double[] poseComponents;
    if (alliance == Alliance.Blue) {
      poseComponents = visionData.getEntry("botpose_wpiblue").getDoubleArray(new double[6]);
      robotPose = new Pose3d(
          poseComponents[0],
          poseComponents[1],
          poseComponents[2],
          new Rotation3d(
              poseComponents[3],
              poseComponents[4],
              poseComponents[5]));
    } else if (alliance == Alliance.Red) {
      poseComponents = visionData.getEntry("botpose_wpired").getDoubleArray(new double[6]);
      robotPose = new Pose3d(
          poseComponents[0],
          poseComponents[1],
          poseComponents[2],
          new Rotation3d(
              Math.toRadians(poseComponents[3]),
              Math.toRadians(poseComponents[4]),
              Math.toRadians(poseComponents[5])));
    } else {
      return null;
    }
    return robotPose;
  }

  /**
   * Method to drive the robot using joystick info.
   *
   * @param xSpeed        Speed of the robot in the x direction (forward).
   * @param ySpeed        Speed of the robot in the y direction (sideways).
   * @param rot           Angular rate of the robot.
   * @param fieldRelative Whether the provided x and y speeds are relative to the
   *                      field.
   */
  /**
   * Sets the wheels into an X formation to prevent movement.
   */
  public void setX() {
    m_frontLeft.setDesiredState(new SwerveModuleState(0, Rotation2d.fromDegrees(45)));
    m_frontRight.setDesiredState(new SwerveModuleState(0, Rotation2d.fromDegrees(-45)));
    m_backLeft.setDesiredState(new SwerveModuleState(0, Rotation2d.fromDegrees(-45)));
    m_backRight.setDesiredState(new SwerveModuleState(0, Rotation2d.fromDegrees(45)));
  }

  /**
   * Sets the swerve ModuleStates.
   *
   * @param desiredStates The desired SwerveModule states.
   */
  public void setModuleStates(SwerveModuleState[] desiredStates) {
    SwerveDriveKinematics.desaturateWheelSpeeds(
        desiredStates, DriveConstants.kMaxSpeedMetersPerSecond);
    m_frontLeft.setDesiredState(desiredStates[0]);
    m_frontRight.setDesiredState(desiredStates[1]);
    m_backLeft.setDesiredState(desiredStates[2]);
    m_backRight.setDesiredState(desiredStates[3]);
  }

  /** Resets the drive encoders to currently read a position of 0. */
  public void resetEncoders() {
    m_frontLeft.resetEncoders();
    m_backLeft.resetEncoders();
    m_frontRight.resetEncoders();
    m_backRight.resetEncoders();
  }

  /** Zeroes the heading of the robot. */
  public void zeroHeading() {
    m_gyro.zeroYaw();
  }

  /**
   * Returns the heading of the robot.
   *
   * @return the robot's heading in degrees, from -180 to 180
   */
  public double getHeading() {
    return Rotation2d.fromDegrees(m_gyro.getYaw()).getDegrees();
  }

  /**
   * Returns the turn rate of the robot.
   *
   * @return The turn rate of the robot, in degrees per second
   */
  public double getTurnRate() {
    return m_gyro.getRate() * (DriveConstants.kGyroReversed ? -1.0 : 1.0);
  }

  public boolean getFieldOriented() {
    return m_fieldOriented;
  }

  public void setFieldOriented(boolean fieldOriented) {
    m_fieldOriented = fieldOriented;
  }

  public double getDriveLockLR() {
    return m_driveLockLR;
  }

  public void setDriveLockLR(double lockDriveLR) {
    m_driveLockLR = lockDriveLR;
  }

  public double getDriveLockFR() {
    return m_driveLockFR;
  }

  public void setDriveLockFR(double lockDriveFR) {
    m_driveLockFR = lockDriveFR;
  }

  public double getRotationLock() {
    return m_rotationLock;
  }

  public void setRotationLock(double lockRotation) {
    m_rotationLock = lockRotation;
  }

  public boolean getSlew() {
    return m_slew;
  }

  public void setSlew(boolean slew) {
    m_slew = slew;
  }

  public void setDrive(double xSpeed, double ySpeed, double rot, boolean fieldRelative, boolean rateLimit) {
    double xSpeedCommanded;
    double ySpeedCommanded;
    double targetXSpeed = motorRampDelta(DriveConstants.kMaxChange, xSpeed, m_currentXSpeed);
    double targetYSpeed = motorRampDelta(DriveConstants.kMaxChange, ySpeed, m_currentYSpeed);

    if (rateLimit) {
      // Should not hit this code, slew is false
      // Convert XY to polar for rate limiting
      double inputTranslationDir = Math.atan2(targetYSpeed, targetXSpeed);
      double inputTranslationMag = Math.sqrt(Math.pow(targetXSpeed, 2) + Math.pow(targetYSpeed, 2));

      // Calculate the direction slew rate based on an estimate of the lateral
      // acceleration
      double directionSlewRate;
      if (m_currentTranslationMag != 0.0) {
        directionSlewRate = Math.abs(DriveConstants.kDirectionSlewRate / m_currentTranslationMag);
      } else {
        directionSlewRate = 500.0; // a high so slew rate is effectively instantaneous
      }

      double currentTime = WPIUtilJNI.now() * 1e-6;
      double elapsedTime = currentTime - m_prevTime;
      double angleDif = SwerveUtils.AngleDifference(inputTranslationDir, m_currentTranslationDir);
      if (angleDif < 0.45 * Math.PI) {
        m_currentTranslationDir = SwerveUtils.StepTowardsCircular(m_currentTranslationDir, inputTranslationDir,
            directionSlewRate * elapsedTime);
        m_currentTranslationMag = m_magLimiter.calculate(inputTranslationMag);
      } else if (angleDif > 0.85 * Math.PI) {
        if (m_currentTranslationMag > 1e-4) { // a small number to avoid floating-point errors with equality checking
          m_currentTranslationMag = m_magLimiter.calculate(0.0);
        } else {
          m_currentTranslationDir = SwerveUtils.WrapAngle(m_currentTranslationDir + Math.PI);
          m_currentTranslationMag = m_magLimiter.calculate(inputTranslationMag);
        }
      } else {
        m_currentTranslationDir = SwerveUtils.StepTowardsCircular(m_currentTranslationDir, inputTranslationDir,
            directionSlewRate * elapsedTime);
        m_currentTranslationMag = m_magLimiter.calculate(0.0);
      }
      m_prevTime = currentTime;

      xSpeedCommanded = m_currentTranslationMag * Math.cos(m_currentTranslationDir) * getMaxDriveSpeed();
      ySpeedCommanded = m_currentTranslationMag * Math.sin(m_currentTranslationDir) * getMaxDriveSpeed();
      m_currentRotation = m_rotLimiter.calculate(rot) * getMaxRotationalSpeed();

    } else {

      xSpeedCommanded = targetXSpeed * getMaxDriveSpeed();
      ySpeedCommanded = targetYSpeed * getMaxDriveSpeed();
      m_currentRotation = rot * getMaxRotationalSpeed();
    }

    // Convert the commanded speeds into the correct units for the drivetrain
    double xSpeedDelivered = xSpeedCommanded * DriveConstants.kMaxSpeedMetersPerSecond;
    double ySpeedDelivered = ySpeedCommanded * DriveConstants.kMaxSpeedMetersPerSecond;
    double rotDelivered = m_currentRotation * DriveConstants.kMaxAngularSpeed;

    var swerveModuleStates = DriveConstants.kDriveKinematics.toSwerveModuleStates(
        fieldRelative
            ? ChassisSpeeds.fromFieldRelativeSpeeds(xSpeedDelivered, ySpeedDelivered, rotDelivered,
                Rotation2d.fromDegrees(m_gyro.getYaw() + getFieldOffsetAngle()))
            : new ChassisSpeeds(xSpeedDelivered, ySpeedDelivered, rotDelivered));
    SwerveDriveKinematics.desaturateWheelSpeeds(
        swerveModuleStates, DriveConstants.kMaxSpeedMetersPerSecond);
    m_frontLeft.setDesiredState(swerveModuleStates[0]);
    m_frontRight.setDesiredState(swerveModuleStates[1]);
    m_backLeft.setDesiredState(swerveModuleStates[2]);
    m_backRight.setDesiredState(swerveModuleStates[3]);
    m_currentXSpeed = targetXSpeed;
    m_currentYSpeed = targetYSpeed;
  }

  public double motorRampDelta(double maxChange, double targetSpeed, double currentSpeed) {
    if (Math.abs(targetSpeed) < Math.abs(currentSpeed)) {
      return targetSpeed;
    } else if (maxChange + currentSpeed > targetSpeed && currentSpeed - maxChange < targetSpeed) {
      return targetSpeed;
    } else if (currentSpeed < targetSpeed) {
      return currentSpeed + maxChange;
    } else if (currentSpeed > targetSpeed) {
      return currentSpeed - maxChange;
    } else {
      // really bad if you get here
      return 0;
    }
  }

  public double getPitch() {
    return m_gyro.getPitch();
  }

  public double getRoll() {
    return m_gyro.getRoll();
  }

  public double getYaw() {
    return m_gyro.getYaw();
  }

  public void setFieldOffsetAngle(double angle) {
    fieldOffsetAngle = Math.toDegrees(MathUtil.angleModulus(Math.toRadians(angle)));
  }

  public double getFieldOffsetAngle() {
    return fieldOffsetAngle;
  }

  public void setRotationAmount(double rot) {
    rotAmount = rot;
  }

  public double getRotationAmount() {
    return rotAmount;
  }

  private void updateFieldOffset() {
    double angle = SmartDashboard.getNumber("Field Oriented Angle Offset", 0);
    if ((angle != getFieldOffsetAngle())) {
      setFieldOffsetAngle(angle);
    }
  }

  public Command followTrajectoryCommand(PathPlannerTrajectory pathPlannerTrajectory, boolean isFirstPath) {
    return new SequentialCommandGroup(
        new InstantCommand(() -> {
          // Reset odometry for the first path you run during auto
          if (isFirstPath) {
            // Should mirror the path depending on which alliance you are.
            PathPlannerTrajectory transformed = PathPlannerTrajectory.transformTrajectoryForAlliance(
                pathPlannerTrajectory,
                DriverStation.getAlliance());
            this.resetOdometry(transformed.getInitialHolonomicPose());
          }
        }),
        new PPSwerveControllerCommand(
            pathPlannerTrajectory,
            this::getPose, // Pose supplier
            DriveConstants.kDriveKinematics, // SwerveDriveKinematics
            new PIDController(AutoConstants.kDrivingP, AutoConstants.kDrivingI, AutoConstants.kDrivingD), // X
                                                                                                          // controller.
                                                                                                          // Tune these
                                                                                                          // values for
                                                                                                          // your robot.
                                                                                                          // Leaving
                                                                                                          // them 0 will
                                                                                                          // only use
                                                                                                          // feedforwards.
            new PIDController(AutoConstants.kDrivingP, AutoConstants.kDrivingI, AutoConstants.kDrivingD), // Y
                                                                                                          // controller
                                                                                                          // (usually
                                                                                                          // the same
                                                                                                          // values as X
                                                                                                          // controller)
            new PIDController(AutoConstants.kTurningP, AutoConstants.kTurningI, AutoConstants.kTurningD), // Rotation
                                                                                                          // controller.
                                                                                                          // Tune these
                                                                                                          // values for
                                                                                                          // your robot.
                                                                                                          // Leaving
                                                                                                          // them 0 will
                                                                                                          // only use
                                                                                                          // feedforwards.
            this::setModuleStates, // Module states consumer
            true, // Should the path be automatically mirrored depending on alliance color.
                  // Optional, defaults to true
            this // Requires this drive subsystem
        ));
  }
}
