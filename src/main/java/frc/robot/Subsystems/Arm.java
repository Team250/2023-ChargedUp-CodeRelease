// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import frc.robot.Constants.ArmConstants;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMax.SoftLimitDirection;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import com.revrobotics.CANSparkMax;

import edu.wpi.first.wpilibj.SerialPort;
import com.revrobotics.SparkMaxAnalogSensor;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class Arm extends SubsystemBase {
    private CANSparkMax m_armController;
    private SparkMaxAnalogSensor m_analogSensor;
    public float kSoftLimitTop, kSoftLimitBot;
    public double maxRPM, maxAcc, maxVel, minVel, allowedErr;
    private double m_setPoint;
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    /**
    *
    */
    public Arm() {
        // SparkMax for Linear Actuator
        m_armController = new CANSparkMax(ArmConstants.kArmCanId, MotorType.kBrushed);
        m_armController.setIdleMode(IdleMode.kBrake);
        m_armController.setInverted(true);

        // POT Embeded in linear Actuator
        m_analogSensor = m_armController.getAnalog(SparkMaxAnalogSensor.Mode.kAbsolute);
        m_analogSensor.setPositionConversionFactor(ArmConstants.kArmPositionFactor);

        // Target Setpoint
        m_setPoint = getCurrentPosition();

        // Limits
        kSoftLimitTop = (float) 4.15;
        kSoftLimitBot = (float) 0.3;
        maxRPM = 500;

        // Smart Motion Coefficients
        maxVel = 2000; // rpm
        maxAcc = 1500;

        // Soft Limit Switch Setup
        m_armController.enableSoftLimit(SoftLimitDirection.kForward, true);
        m_armController.enableSoftLimit(SoftLimitDirection.kReverse, true);
        m_armController.setSoftLimit(SoftLimitDirection.kForward, kSoftLimitTop);
        m_armController.setSoftLimit(SoftLimitDirection.kReverse, kSoftLimitBot);
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
        moveTowardTarget(m_setPoint);
    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation
    }

    public void setTargetPosition(double setPoint) {
        m_setPoint = setPoint;
    }

    public void moveTowardTarget(double setPoint) {
        if (!isAtSetpoint()) {
            if (setPoint > getCurrentPosition()) {
                m_armController.set(ArmConstants.kRaisingSpeed);
            } else {
                m_armController.set(-ArmConstants.kLoweringSpeed);
            }
        } else {
            m_armController.set(0);
        }
    }

    public double getSetpoint() {
        return m_setPoint;
    }

    public double getCurrentPosition() {
        return m_analogSensor.getPosition();
    }

    public double getArmControllerAppliedOutput(){
        return m_armController.getAppliedOutput();
    }

    public boolean isAtSetpoint() {
        return m_analogSensor.getPosition() < m_setPoint + .1 && m_analogSensor.getPosition() > m_setPoint - .1;
    }
}
